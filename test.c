//
// Goal of tests: we record the behavior of the library.
// When we change something, the library must still generate the same images.

#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <stdio.h>
#include <errno.h>
#define PASTEL_IMPLEMENTATION
#include "pastel.h"
#define STB_IMAGE_WRITE_IMPLEMENTATION
#include "third-party/stb_image_write.h"
#define STB_IMAGE_IMPLEMENTATION
#include "third-party/stb_image.h"

#define TEST_DIR_PATH "./test"
#define TEST_DIFF_DIR_PATH TEST_DIR_PATH"/diff"

#define UNIMPLEMENTED(message) \
  do { \
    fprintf(stderr, "%s:%d: UNIMPLEMENTED: %s\n", __FILE__, __LINE__, message); \
    exit(1); \
  } while (0)
#define return_defer(value) do { result = (value); goto defer; } while (0)

#define WIDTH  160
#define HEIGHT 120
static Color pixels[HEIGHT * WIDTH];
#define PIXEL_DIFF_COLOR 0xFFC934EB

bool record_test_case(const char* file_path) {
  printf("Generated image %s\n", file_path);
  if (!stbi_write_png(file_path, WIDTH, HEIGHT, 4, pixels, WIDTH*sizeof(Color))) {
      fprintf(stderr, "ERROR: could not save file %s: %s\n", file_path, strerror(errno));
      return false;
  }
  return true;
}

bool test_case(const char* file_path, const char* diff_file_path) {
  // Load existing image
  bool result = true;
  Color* expected_pixels = NULL;

  {
    int expected_width, expected_height;
    expected_pixels = (Color*)stbi_load(file_path, &expected_width, &expected_height, NULL, 4);
    if (expected_pixels == NULL) {
      fprintf(stderr, "ERROR: could not read file %s: %s\n", file_path, strerror(errno));
      return_defer(false);
    }

    if (expected_width != WIDTH || expected_height != HEIGHT) {
      fprintf(stderr, "ERROR: unexpected image size for %s. Expected %dx%d but got %dx%d\n", file_path, expected_width, expected_height, WIDTH, HEIGHT);
      return_defer(false);
    }

    bool failed = false;
    for (size_t y = 0; y < HEIGHT; ++y) {
      for (size_t x = 0; x < HEIGHT; ++x) {
        Color p1 = expected_pixels[y * HEIGHT + x];
        Color p2 = pixels[y * HEIGHT + x];
        if (p1 != p2) {
          pixels[y * HEIGHT + x] = PIXEL_DIFF_COLOR;
          failed = true;
        }
      }
    }

    if (failed) {
      fprintf(stderr, "TEST FAILED: unexpected pixels in image generated by %s.\n", file_path);
      if (!stbi_write_png(diff_file_path, WIDTH, HEIGHT, 4, pixels, WIDTH*sizeof(Color))) {
        fprintf(stderr, "ERROR: could not save file %s: %s\n", file_path, strerror(errno));
      } else {
      printf("Check out diff image %s\n", diff_file_path);
      }
        return_defer(false);
      }
    }
  printf("%s OK\n", file_path);

defer:
  if (expected_pixels) stbi_image_free(expected_pixels);
  return result;
}

typedef struct {
  void (*run)(void);
  const char* file_path;
  const char* diff_file_path;
} TestCase;

#define DEFINE_TEST_CASE(name) \
  { \
  .run = name, \
  .file_path = TEST_DIR_PATH "/" #name ".png", \
  .diff_file_path = TEST_DIFF_DIR_PATH "/diff_" #name ".png", \
  }

void test_fill_rect(void) {
  PastelCanvas canvas = pastel_canvas_create(pixels, WIDTH, HEIGHT);

  PastelShaderContextMonochrome context;
  PastelShader shader = {pastel_shader_func_monochrome, &context};

  context.color = PASTEL_BLACK;
  pastel_fill(canvas, shader);

  Vec2i pos; Vec2ui dim;

  context.color = PASTEL_BLUE;
  pos.x = 0; pos.y = 0;
  dim.x = 80; dim.y = 40;
  pastel_fill_rect(canvas, &pos, &dim, shader);

  context.color = PASTEL_RED;
  pos.x = WIDTH-60; pos.y = HEIGHT-60;
  dim.x = 60; dim.y = 60;
  pastel_fill_rect(canvas, &pos, &dim, shader);

  context.color = PASTEL_GREEN;
  pos.x = (WIDTH-60)/2; pos.y = (HEIGHT-60)/2;
  dim.x = 80; dim.y = 60;
  pastel_fill_rect(canvas, &pos, &dim, shader);
}

void test_fill_circle(void) {
  PastelCanvas canvas = pastel_canvas_create(pixels, WIDTH, HEIGHT);

  PastelShaderContextMonochrome context;
  PastelShader shader = {pastel_shader_func_monochrome, &context};

  context.color = PASTEL_BLACK;
  pastel_fill(canvas, shader);

  Vec2i pos;

  context.color = PASTEL_RED;
  pos.x = 0; pos.y = 0;
  pastel_fill_circle(canvas, &pos, 40, shader);

  context.color = PASTEL_GREEN;
  pos.x = WIDTH/2; pos.y = HEIGHT/2;
  pastel_fill_circle(canvas, &pos, 45, shader);

  context.color = PASTEL_BLUE;
  pos.x = WIDTH; pos.y = HEIGHT;
  pastel_fill_circle(canvas, &pos, 60, shader);
}

void test_draw_line(void) {
  PastelCanvas canvas = pastel_canvas_create(pixels, WIDTH, HEIGHT);

  PastelShaderContextMonochrome context;
  PastelShader shader = {pastel_shader_func_monochrome, &context};

  context.color = PASTEL_BLACK;
  pastel_fill(canvas, shader);

  Vec2i p1, p2;

  //
  // Side lines
  context.color = PASTEL_RED;
  p1.x = 0; p1.y = 0;
  p2.x = 0; p2.y = HEIGHT-1;
  pastel_draw_line(canvas, &p1, &p2, shader);

  p1.x = WIDTH-1; p1.y = 0;
  p2.x = WIDTH-1; p2.y = HEIGHT-1;
  pastel_draw_line(canvas, &p1, &p2, shader);

  //
  // Middle lines
  context.color = PASTEL_GREEN;
  p1.x = WIDTH/2; p1.y = HEIGHT-1;
  p2.x = WIDTH/2; p2.y = 0;
  pastel_draw_line(canvas, &p1, &p2, shader);

  p1.x = 0; p1.y = HEIGHT/2;
  p2.x = WIDTH-1; p2.y = HEIGHT/2;
  pastel_draw_line(canvas, &p1, &p2, shader);

  //
  // Diagonal lines
  context.color = PASTEL_BLUE;
  p1.x = 0; p1.y = 0;
  p2.x = WIDTH-1; p2.y = HEIGHT-1;
  pastel_draw_line(canvas, &p1, &p2, shader);

  p1.x = 0; p1.y = HEIGHT-1;
  p2.x = WIDTH-1; p2.y = 0;
  pastel_draw_line(canvas, &p1, &p2, shader);
}

void test_fill_triangle(void) {
  PastelCanvas canvas = pastel_canvas_create(pixels, WIDTH, HEIGHT);

  PastelShaderContextMonochrome context;
  PastelShader shader = {pastel_shader_func_monochrome, &context};

  context.color = PASTEL_BLACK;
  pastel_fill(canvas, shader);

  Vec2i p1, p2, p3;

  context.color = PASTEL_RED;
  p1.x = 0; p1.y = HEIGHT/2;
  p2.x = (WIDTH-1)/2; p2.y = HEIGHT-1;
  p3.x = (2*WIDTH)/3; p3.y = 0;
  pastel_fill_triangle(canvas, &p1, &p2, &p3, shader);

  context.color = PASTEL_GREEN;
  p1.x = 0; p1.y = HEIGHT/4;
  p2.x = (2*WIDTH)/3; p2.y = (5*HEIGHT)/6;
  p3.x = (3*WIDTH)/4; p3.y = (2*HEIGHT)/3;
  pastel_fill_triangle(canvas, &p1, &p2, &p3, shader);

  context.color = PASTEL_BLUE;
  p1.x = (2*WIDTH)/3; p1.y = HEIGHT/4;
  p2.x = WIDTH-1; p2.y = HEIGHT/2;
  p3.x = (4*WIDTH)/5; p3.y = (3*HEIGHT)/4;
  pastel_fill_triangle(canvas, &p1, &p2, &p3, shader);
}

typedef struct {
  Color* colors;
  size_t color_index;
  size_t count;
} ContextLineThreeColors;

// @param `context` is a ptr to `ContextLineThreeColors`
PASTELDEF Color line_shader_func1(int x, int y, void* context) {
  PASTEL_UNUSED(x); PASTEL_UNUSED(y);
  ContextLineThreeColors* _context = (ContextLineThreeColors*)context;
  if (_context->count == 10) {
    _context->color_index++;
    if (_context->color_index > 2) _context->color_index = 0;
    _context->count = 0;
  } else {
    _context->count++;
  }
  return _context->colors[_context->color_index];
}

typedef struct {
  Color c1;
  Color c2;
} ContextTwoColors;

// @param `context` is a ptr to `ContextTwoColors`
PASTELDEF Color line_shader_func2(int x, int y, void* context) {
  PASTEL_UNUSED(y);
  ContextTwoColors* _context = (ContextTwoColors*) context;
  if (x < WIDTH/2) {
    return _context->c1; // red
  }
  return _context->c2; // green
}

// @param `context` is a ptr to `ContextTwoColors`
PASTELDEF Color line_shader_func3(int x, int y, void* context) {
  PASTEL_UNUSED(x);
  ContextTwoColors* _context = (ContextTwoColors*) context;
  if (y < HEIGHT/2) {
    return _context->c1; // blue
  }
  return _context->c2; // yellow
}

void test_draw_line_with_shader(void) {
  PastelCanvas canvas = pastel_canvas_create(pixels, WIDTH, HEIGHT);

  PastelShaderContextMonochrome mono_context;
  PastelShader mono_shader = {pastel_shader_func_monochrome, &mono_context};

  mono_context.color = PASTEL_BLACK;
  pastel_fill(canvas, mono_shader);

  Vec2i p1, p2;

  //
  // Middle lines
  Color colors[3] = { PASTEL_RED, PASTEL_GREEN, PASTEL_BLUE };
  ContextLineThreeColors context_middle = {colors, 0, 0};
  PastelShader shader_middle = {line_shader_func1, &context_middle};

  p1.x = WIDTH/2; p1.y = HEIGHT-1;
  p2.x = WIDTH/2; p2.y = 0;
  pastel_draw_line(canvas, &p1, &p2, shader_middle);

  p1.x = 0; p1.y = HEIGHT/2;
  p2.x = WIDTH-1; p2.y = HEIGHT/2;
  pastel_draw_line(canvas, &p1, &p2, shader_middle);

  //
  // Diagonal lines
  ContextTwoColors context_diagonal;
  PastelShader shader_diagonal = {line_shader_func2, &context_diagonal};

  context_diagonal.c1 = PASTEL_RED; context_diagonal.c2 = PASTEL_GREEN;
  p1.x = 0; p1.y = HEIGHT-1;
  p2.x = WIDTH-1; p2.y = 0;
  pastel_draw_line(canvas, &p1, &p2, shader_diagonal);

  context_diagonal.c1 = PASTEL_BLUE; context_diagonal.c2 = PASTEL_YELLOW;
  shader_diagonal.run = line_shader_func3;
  p1.x = 0; p1.y = 0;
  p2.x = WIDTH-1; p2.y = HEIGHT-1;
  pastel_draw_line(canvas, &p1, &p2, shader_diagonal);
}

TestCase test_cases[] = {
  DEFINE_TEST_CASE(test_fill_rect),
  DEFINE_TEST_CASE(test_fill_circle),
  DEFINE_TEST_CASE(test_draw_line),
  DEFINE_TEST_CASE(test_draw_line_with_shader),
  DEFINE_TEST_CASE(test_fill_triangle),
};

#define TESTS_CASES_COUNT (sizeof(test_cases) / sizeof(test_cases[0]))

// Second argument of main must be char**.
// A char*[] is the same thing.
int main (int argc, char* argv[]) {
  // argc is always >= 0 and argv[0] is always the program's name.
  bool record = (argc >= 2 && strcmp(argv[1], "record") == 0);

  for (size_t i = 0; i < TESTS_CASES_COUNT; ++i) {
    test_cases[i].run();
    if (record) {
      // Save generated image
      if (!record_test_case(test_cases[i].file_path)) return 1;
    } else {
      // Compare generated image to image stored in test
      if (!test_case(test_cases[i].file_path, test_cases[i].diff_file_path)) return 1;
    }
  }
  return 0;
}
