//
// Goal of tests: we record the behavior of the library.
// When we change something, the library must still generate the same images.

#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <stdio.h>
#include <errno.h>
#define PASTEL_TEST_IMPLEMENTATION
#include "test.h"
#define STB_IMAGE_WRITE_IMPLEMENTATION
#include "third-party/stb_image_write.h"
#define STB_IMAGE_IMPLEMENTATION
#include "third-party/stb_image.h"

#define TEST_DIR_PATH "./test"
#define TEST_DIFF_DIR_PATH TEST_DIR_PATH"/diff"

#define UNIMPLEMENTED(message) \
  do { \
    fprintf(stderr, "%s:%d: UNIMPLEMENTED: %s\n", __FILE__, __LINE__, message); \
    exit(1); \
  } while (0)
#define return_defer(value) do { result = (value); goto defer; } while (0)

#define WIDTH  160
#define HEIGHT 120
static Color pixels[HEIGHT * WIDTH];
#define PIXEL_DIFF_COLOR 0xFFC934EB

bool record_test_case(const char* file_path) {
  printf("Generated image %s\n", file_path);
  if (!stbi_write_png(file_path, WIDTH, HEIGHT, 4, pixels, WIDTH*sizeof(Color))) {
      fprintf(stderr, "ERROR: could not save file %s: %s\n", file_path, strerror(errno));
      return false;
  }
  return true;
}

bool test_case(const char* file_path, const char* diff_file_path) {
  // Load existing image
  bool result = true;
  Color* expected_pixels = NULL;

  {
    int expected_width, expected_height;
    expected_pixels = (Color*)stbi_load(file_path, &expected_width, &expected_height, NULL, 4);
    if (expected_pixels == NULL) {
      fprintf(stderr, "ERROR: could not read file %s: %s\n", file_path, strerror(errno));
      return_defer(false);
    }

    if (expected_width != WIDTH || expected_height != HEIGHT) {
      fprintf(stderr, "ERROR: unexpected image size for %s. Expected %dx%d but got %dx%d\n", file_path, expected_width, expected_height, WIDTH, HEIGHT);
      return_defer(false);
    }

    bool failed = false;
    for (size_t y = 0; y < HEIGHT; ++y) {
      for (size_t x = 0; x < HEIGHT; ++x) {
        Color p1 = expected_pixels[y * HEIGHT + x];
        Color p2 = pixels[y * HEIGHT + x];
        if (p1 != p2) {
          pixels[y * HEIGHT + x] = PIXEL_DIFF_COLOR;
          failed = true;
        }
      }
    }

    if (failed) {
      fprintf(stderr, "TEST FAILED: unexpected pixels in image generated by %s.\n", file_path);
      if (!stbi_write_png(diff_file_path, WIDTH, HEIGHT, 4, pixels, WIDTH*sizeof(Color))) {
        fprintf(stderr, "ERROR: could not save file %s: %s\n", file_path, strerror(errno));
      } else {
      printf("Check out diff image %s\n", diff_file_path);
      }
        return_defer(false);
      }
    }
  printf("%s OK\n", file_path);

defer:
  if (expected_pixels) stbi_image_free(expected_pixels);
  return result;
}

typedef struct {
  void (*run)(void);
  const char* file_path;
  const char* diff_file_path;
} TestCase;

#define DEFINE_TEST_CASE(name) \
  { \
  .run = name, \
  .file_path = TEST_DIR_PATH "/" #name ".png", \
  .diff_file_path = TEST_DIFF_DIR_PATH "/diff_" #name ".png", \
  }

void test_fill_rect(void) {
  PastelCanvas canvas = pastel_canvas_create(pixels, WIDTH, HEIGHT);
  pastel_test_fill_rects(&canvas);
}

void test_fill_circle(void) {
  PastelCanvas canvas = pastel_canvas_create(pixels, WIDTH, HEIGHT);
  pastel_test_fill_circles(&canvas);
}

void test_draw_line(void) {
  PastelCanvas canvas = pastel_canvas_create(pixels, WIDTH, HEIGHT);
  pastel_test_draw_lines(&canvas);
}

void test_fill_triangle(void) {
  PastelCanvas canvas = pastel_canvas_create(pixels, WIDTH, HEIGHT);
  pastel_test_fill_triangles(&canvas);
}

void test_draw_line_with_shader(void) {
  PastelCanvas canvas = pastel_canvas_create(pixels, WIDTH, HEIGHT);
  pastel_test_draw_lines_with_shaders(&canvas);
}

void test_gradientx(void) {
  PastelCanvas canvas = pastel_canvas_create(pixels, WIDTH, HEIGHT);
  pastel_test_gradientx(&canvas);
}

void test_gradienty(void) {
  PastelCanvas canvas = pastel_canvas_create(pixels, WIDTH, HEIGHT);
  pastel_test_gradienty(&canvas);
}

void test_alpha_blending(void) {
  PastelCanvas canvas = pastel_canvas_create(pixels, WIDTH, HEIGHT);
  pastel_test_alpha_blending(&canvas);
}

TestCase test_cases[] = {
  DEFINE_TEST_CASE(test_fill_rect),
  DEFINE_TEST_CASE(test_fill_circle),
  DEFINE_TEST_CASE(test_draw_line),
  DEFINE_TEST_CASE(test_fill_triangle),
  DEFINE_TEST_CASE(test_draw_line_with_shader),
  DEFINE_TEST_CASE(test_gradientx),
  DEFINE_TEST_CASE(test_gradienty),
  DEFINE_TEST_CASE(test_alpha_blending),
};

#define TESTS_CASES_COUNT (sizeof(test_cases) / sizeof(test_cases[0]))

// Second argument of main must be char**.
// A char*[] is the same thing.
int main (int argc, char* argv[]) {
  // argc is always >= 0 and argv[0] is always the program's name.
  bool record = (argc >= 2 && strcmp(argv[1], "record") == 0);

  for (size_t i = 0; i < TESTS_CASES_COUNT; ++i) {
    test_cases[i].run();
    if (record) {
      // Save generated image
      if (!record_test_case(test_cases[i].file_path)) return 1;
    } else {
      // Compare generated image to image stored in test
      if (!test_case(test_cases[i].file_path, test_cases[i].diff_file_path)) return 1;
    }
  }
  return 0;
}
