//
// Goal of tests: we record the behavior of the library.
// When we change something, the library must still generate the same images.

#include <_types/_uint32_t.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include "pastel.h"
#define STB_IMAGE_WRITE_IMPLEMENTATION
#include "third-party/stb_image_write.h"
#define STB_IMAGE_IMPLEMENTATION
#include "third-party/stb_image.h"

#define TEST_DIR_PATH "./test"
#define TEST_DIFF_DIR_PATH TEST_DIR_PATH"/diff"

#define UNIMPLEMENTED(message) \
  do { \
    fprintf(stderr, "%s:%d: UNIMPLEMENTED: %s\n", __FILE__, __LINE__, message); \
    exit(1); \
  } while (0)
#define return_defer(value) do { result = (value); goto defer; } while (0)

#define WIDTH  160
#define HEIGHT 120
static uint32_t pixels[HEIGHT * WIDTH];
#define PIXEL_DIFF_COLOR 0xFFC934EB

bool record_test_case(const char* file_path) {
  printf("Generated image %s\n", file_path);
  if (!stbi_write_png(file_path, WIDTH, HEIGHT, 4, pixels, WIDTH*sizeof(uint32_t))) {
      fprintf(stderr, "ERROR: could not save file %s: %s\n", file_path, strerror(errno));
      return false;
  }
  return true;
}

bool test_case(const char* file_path, const char* diff_file_path) {
  // Load existing image
  bool result = true;
  uint32_t* expected_pixels = NULL;

  {
    int expected_width, expected_height;
    expected_pixels = (uint32_t*)stbi_load(file_path, &expected_width, &expected_height, NULL, 4);
    if (expected_pixels == NULL) {
      fprintf(stderr, "ERROR: could not read file %s: %s\n", file_path, strerror(errno));
      return_defer(false);
    }

    if (expected_width != WIDTH || expected_height != HEIGHT) {
      fprintf(stderr, "ERROR: unexpected image size for %s. Expected %dx%d but got %dx%d\n", file_path, expected_width, expected_height, WIDTH, HEIGHT);
      return_defer(false);
    }

    bool failed = false;
    for (size_t y = 0; y < HEIGHT; ++y) {
      for (size_t x = 0; x < HEIGHT; ++x) {
        uint32_t p1 = expected_pixels[y * HEIGHT + x];
        uint32_t p2 = pixels[y * HEIGHT + x];
        if (p1 != p2) {
          pixels[y * HEIGHT + x] = PIXEL_DIFF_COLOR;
          failed = true;
        }
      }
    }

    if (failed) {
      fprintf(stderr, "TEST FAILED: unexpected pixels in image generated by %s.\n", file_path);
      if (!stbi_write_png(diff_file_path, WIDTH, HEIGHT, 4, pixels, WIDTH*sizeof(uint32_t))) {
        fprintf(stderr, "ERROR: could not save file %s: %s\n", file_path, strerror(errno));
      } else {
      printf("Check out diff image %s\n", diff_file_path);
      }
        return_defer(false);
      }
    }
  printf("%s OK\n", file_path);

defer:
  if (expected_pixels) stbi_image_free(expected_pixels);
  return result;
}

typedef struct {
  void (*run)(void);
  const char* file_path;
  const char* diff_file_path;
} TestCase;

#define DEFINE_TEST_CASE(name) \
  { \
  .run = name, \
  .file_path = TEST_DIR_PATH "/" #name ".png", \
  .diff_file_path = TEST_DIFF_DIR_PATH "/diff_" #name ".png", \
  }

void test_fill_rect(void) {
  pastel_fill(pixels, WIDTH, HEIGHT, PASTEL_BLACK);
  pastel_fill_rect(pixels, WIDTH, HEIGHT, 0, 0, 80, 40, PASTEL_BLUE);
  pastel_fill_rect(pixels, WIDTH, HEIGHT, WIDTH - 60, HEIGHT - 60, 60, 60, PASTEL_RED);
  pastel_fill_rect(pixels, WIDTH, HEIGHT, (WIDTH - 60) / 2, (HEIGHT - 60) / 2, 80, 60, PASTEL_GREEN);
}

void test_fill_circle(void) {
  pastel_fill(pixels, WIDTH, HEIGHT, PASTEL_BLACK);
  pastel_fill_circle(pixels, WIDTH, HEIGHT, 0, 0, 40, PASTEL_RED);
  pastel_fill_circle(pixels, WIDTH, HEIGHT, WIDTH / 2, HEIGHT / 2, 45, PASTEL_GREEN);
  pastel_fill_circle(pixels, WIDTH, HEIGHT, WIDTH, HEIGHT, 60, PASTEL_BLUE);
}

void test_draw_line(void) {
  pastel_fill(pixels, WIDTH, HEIGHT, PASTEL_BLACK);
  // Side lines
  pastel_draw_line(pixels, WIDTH, HEIGHT, 0, 0, 0, HEIGHT-1, PASTEL_RED);
  pastel_draw_line(pixels, WIDTH, HEIGHT, WIDTH-1, 0, WIDTH-1, HEIGHT-1, PASTEL_RED);
  // Middle lines
  pastel_draw_line(pixels, WIDTH, HEIGHT, WIDTH / 2, HEIGHT-1, WIDTH / 2, 0, PASTEL_GREEN);
  pastel_draw_line(pixels, WIDTH, HEIGHT, 0, HEIGHT / 2, WIDTH-1, HEIGHT / 2, PASTEL_GREEN);
  // Diagonal lines
  pastel_draw_line(pixels, WIDTH, HEIGHT, 0, 0, WIDTH-1, HEIGHT-1, PASTEL_BLUE);
  pastel_draw_line(pixels, WIDTH, HEIGHT, 0, HEIGHT-1, WIDTH-1, 0, PASTEL_BLUE);
}

void test_fill_triangle(void) {
  pastel_fill(pixels, WIDTH, HEIGHT, PASTEL_BLACK);
  pastel_fill_triangle2(pixels, WIDTH, HEIGHT,
                       0, HEIGHT / 2,
                       (WIDTH-1)/2, HEIGHT-1,
                       (2*WIDTH)/3, 0,
                       PASTEL_RED);
  pastel_fill_triangle2(pixels, WIDTH, HEIGHT,
                       0, HEIGHT/4,
                       (2*WIDTH)/3, (5*HEIGHT)/6,
                       (3*WIDTH)/4, (2*HEIGHT)/3,
                       PASTEL_GREEN);
  pastel_fill_triangle2(pixels, WIDTH, HEIGHT,
                       (2*WIDTH)/3, HEIGHT/4,
                       WIDTH-1, HEIGHT/2,
                       (4*WIDTH)/5, (3*HEIGHT)/4,
                       PASTEL_BLUE);
}

TestCase test_cases[] = {
  DEFINE_TEST_CASE(test_fill_rect),
  DEFINE_TEST_CASE(test_fill_circle),
  DEFINE_TEST_CASE(test_draw_line),
  DEFINE_TEST_CASE(test_fill_triangle),
};

#define TESTS_CASES_COUNT (sizeof(test_cases) / sizeof(test_cases[0]))

// Second argument of main must be char**.
// A char*[] is the same thing.
int main (int argc, char* argv[]) {
  // argc is always >= 0 and argv[0] is always the program's name.
  bool record = (argc >= 2 && strcmp(argv[1], "record") == 0);

  for (size_t i = 0; i < TESTS_CASES_COUNT; ++i) {
    test_cases[i].run();
    if (record) {
      // Save generated image
      if (!record_test_case(test_cases[i].file_path)) return 1;
    } else {
      // Compare generated image to image stored in test
      if (!test_case(test_cases[i].file_path, test_cases[i].diff_file_path)) return 1;
    }
  }
  return 0;
}
